



## 什么情况会丢消息

+ 生产者将消息发送到broker过程中
+ broker消息存储过程
+ 消费者处理消息失败，返回错误的ack



## 生产消息

#### 消息发送的方式

+ 同步发送：通过等待发送结果
+ 异步发送：通过`SendCallback`来反馈发送成功或失败
+ one-way：不关心发送结果



**`one-way`** 模式不保证消息的不丢失，没有重试机制。

同步发送和异步发送rocketmq内部会有重试机制，（默认1次发送+2次失败重试，共3次）。另外也可以根据发送结果来做额外的处理。



## Broker存储阶段

#### 消息刷盘方式：

+ SYNC_FLUSH：同步刷盘。消息写入内存的 PageCache后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态。这种方式可以保证数据绝对安全，但是吞吐量不大。

+ ASYNC_FLUSH(默认)：异步刷盘。消息写入到内存的 PageCache中，就立刻给客户端返回写操作成功，当 PageCache中的消息积累到一定的量时，触发一次写操作，或者定时等策略将 PageCache中的消息写入到磁盘中。这种方式吞吐量大，性能高，但是 PageCache 中的数据可能丢失，不能保证数据绝对的安全。

  



#### 消息同步方式：

+ SYNC_MASTER：同步主机。当接收到消息后，立即同步到`slave`节点，当`slave`节点同步成功后，才返回成功，可靠性高
+ ASYNC_MASTER(默认)：异步主机。当接收到消息，并不立即同步给`slave`节点，同步操作由后台线程进行，如果在发生主从切换时，同步操作还未进行，就有可能会丢失数据





## 消费消息

消费消息时，可返回两种结果：

- `CONSUME_SUCCESS`：消费成功
- `RECONSUME_LATER`：消费失败，稍后再消费



消费者如果消费不成功，不能给broker端返回ack。一般需要设置为手动提交ack机制，消费者消费消息不成功，不返回CONSUME_SUCCESS，返回RECONSUME_LATER表示需要broker再次投递该消息。



`Consumer`消费消息失败后，`RocketMq`会提供一种重试机制，令消息再消费一次。`Consumer`消费消息失败通常可以认为有以下几种情况：

由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过10秒后再重试。

由于依赖的下游应用服务不可用，例如db连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。



RocketMQ会为每个消费组都设置一个Topic名称为`%RETRY%+consumerGroup`的重试队列（这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的），用于暂时保存因为各种异常而导致Consumer端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ对于重试消息的处理是先保存至Topic名称为`SCHEDULE_TOPIC_XXXX`的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至`%RETRY%+consumerGroup`的重试队列中。

如果`16次之后`，消息还是没有消费成功，Broker端会将消息写入`死信队列`。