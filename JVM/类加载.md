

# 类加载





## 类加载过程

系统加载 Class 类型的文件主要三步：**加载->连接->初始化**。连接过程又可分为三步：**验证->准备->解析**。



### 加载

1. 通过全类名获取定义此类的二进制字节流。
2. 将字节流所代表的静态存储结构转换为**方法区**的运行时数据结构。
3. 在内存中生成一个代表该类的 `Class` 对象，作为**方法区**这些数据的访问入口。

### 连接

#### 验证

**确保 Class 文件的字节流中包含的信息符合Java 虚拟机规范的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。**

#### 准备

**为类变量（static修士的静态变量）分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配.

#### 解析

**将常量池内的符号引用替换为直接引用的过程。** 



### 初始化

为静态变量赋值

1. 声明时即指定初始值，如static int a = 5；
2. 使用静态代码块为静态Field指定初始值，如：static{  b = 5;  } 

**初始化阶段是执行初始化方法 `<clinit> ()`方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。**

> 说明：`<clinit> ()`方法是编译之后自动生成的。



#### 类初始化的时机

+ 创建类的实例时（new、反射、反序列化）。
+ 调用某个类的静态方法时。
+ 使用某个类或接口的静态变量或对该变量赋值时。
+ 使用反射来强制创建某个类或接口对应的java.lang.Class对象，如Class.forName("Person")
+ 初始化某个类的子类时，此时该子类的所有父类都会被初始化。
+ 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 `main` 方法的那个类)，虚拟机会先初始化这个类。



## 类加载器

**类加载器的主要作用就是加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）。** 

每个 Java 类都有一个引用指向加载它的 `ClassLoader`。不过，数组类不是通过 `ClassLoader` 创建的，而是 JVM 在需要的时候自动创建的，数组类通过`getClassLoader()`方法获取 `ClassLoader` 的时候和该数组的元素类型的 `ClassLoader` 是一致的。



JVM 中内置了三个重要的 `ClassLoader`：

1. **`BootstrapClassLoader`(启动类加载器)**：加载**jre和jre/lib目录下的核心库**

2. **`ExtensionClassLoader`(扩展类加载器)**：加载**jre/lib/ext目录下的扩展包**

3. **`AppClassLoader`(应用程序类加载器)**：加载**用户自己编写的Java代码编译成的class文件**

每个 `ClassLoader` 可以通过`getParent()`获取其父 `ClassLoader`，如果获取到 `ClassLoader` 为`null`的话，那么该类是通过 `BootstrapClassLoader` 加载的。



### 双亲委派

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。

`ClassLoader` 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。

```java
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        //首先，检查该类是否已经加载过
        Class c = findLoadedClass(name);
        if (c == null) {
            //如果 c 为 null，则说明该类没有被加载过
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    //当父类的加载器不为空，则通过父类的loadClass来加载该类
                    c = parent.loadClass(name, false);
                } else {
                    //当父类的加载器为空，则调用启动类加载器来加载该类
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                //非空父类的类加载器无法找到相应的类，则抛出异常
            }

            if (c == null) {
                //当父类加载器无法加载时，则调用findClass方法来加载该类
                //用户可通过覆写该方法，来自定义类加载器
                long t1 = System.nanoTime();
                c = findClass(name);

                //用于统计类加载器相关的信息
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            //对类进行link操作
            resolveClass(c);
        }
        return c;
    }
}

```

在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。

类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 `loadClass()`方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 `BootstrapClassLoader` 中。

只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 `findClass()` 方法来加载类）。

如果子类加载器也无法加载这个类，那么它会抛出一个 `ClassNotFoundException` 异常。

> **JVM 判定两个 Java 类是否相同的具体规则**：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。



### 为什么使用双亲委派

双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。

我们自己编写的Java.lang.String类想要被加载，会被层层委派道启动类加载器，启动类加载器发现已经加载过String，就不会加载我们编写的假的String，保证了java核心类库的安全。



### 打破双亲委派

自定义加载器的话，需要继承 `ClassLoader` 。如果我们不想打破双亲委派模型，就重写 `ClassLoader` 类中的 `findClass()` 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 `loadClass()` 方法。

重写 `loadClass()`方法之后，我们就可以改变传统双亲委派模型的执行流程。例如，子类加载器可以在委派给父类加载器之前，先自己尝试加载这个类，或者在父类加载器返回之后，再尝试从其他地方加载这个类。具体的规则由我们自己实现，根据项目需求定制化。



#### Tomcat打破双亲委派

Tomcat作为web容器，可以部署多个web应用。这些应用可能会出现全类名相同的类，也会有相同的类库依赖。为了解决这个问题，tomcat就需要实现类库的共享和隔离。

使用双亲委派，确实可以做到类库的共享，但父类加载的类库，子类也都是可见的。

想要隔离，双亲委派机制就不好用了。

![Tomcat的自定义类加载器 (1).png](D:\blog\docs\JVM\img\类加载.assets\371bea96db5f47b2b442b100cdd98140tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp)

可以看出：

- `WebappClassLoader`可以使用`ShareClassLoader`加载的类，但各个`WebappClassLoader`之间相互隔离
- 针对JSP类，会由专门的JSP类加载器（JasperLoader）进行加载，该加载器会针对JSP类在每次加载时都会解析类文件，Tomcat容器会启动一个后台线程，定时检测JSP类文件的变化，及时更新类文件，这样就实现JSP文件的热加载功能。当发现更新时会创建一个新的JasperLoader来重新加载jsp文件。



tomcat打破了双亲委派机制，来实现不同webapp的资源隔离。





