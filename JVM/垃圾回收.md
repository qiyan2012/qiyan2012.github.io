

## 判断对象死亡的方法



### 引用计数法

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器就减1。

任何时刻计数器为0的对象就是不可能再被使用的。

缺点：循环引用时，计数器永远不为0，可能不再使用的对象就永远得不到回收。

```java
public class Test {

    public Object instance = null;

    public static void main(String[] args) {
        Test a = new Test();
        Test b = new Test();
        a.instance = b;
        b.instance = a;
        a = null;
        b = null;
    }
}
```

### 可达性分析算法

以`GC Roots`的对象为起点，能引用到的对象都是可用的，不被引用到的对象都是不可用的、可以回收的。

`GC Roots`：

+ 虚拟机栈(栈帧中的局部变量表)中引用的对象
+ 本地方法栈(Native 方法)中引用的对象
+ 方法区中类静态属性引用的对象
+ 方法区中常量引用的对象
+ 所有被同步锁持有的对象
+ JNI（Java Native Interface）引用的对象



并不是不被使用的对象就一定会被垃圾回收，垃圾回收本身也会带来开销，甚至Stop the World，所以在内存充足时，GC并不会频繁触发。就算触发，垃圾回收器也会在停顿时间和吞吐量之间做权衡。



> finalize
>
> finalize()方法是[Object类](https://so.csdn.net/so/search?q=Object类&spm=1001.2101.3001.7020)中提供的一个方法，在GC准备释放对象所占用的内存空间之前，它将首先调用finalize()方法。
>
> finalize()最多只会被调用一次，在这一次机会中，可以让该对象变得可达，从而救活他。
>
> 但finalize会影响GC的性能，而且finalize也不会被保证一定执行。
>
> 所以慎用finalize，最好别用。





## 类的垃圾回收

发生在方法区，即类的卸载。条件严苛：
1、该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
2、加载该类的 `ClassLoader`已经被回收。
3、该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
注意：
使用启动类加载器装载的类型永远是可触及的，所以永远不会被卸载。只有使用用户定义的类装载器装载的类型才会变成不可触及的，从而被虚拟机回收



## 垃圾收集算法

### 标记-清除算法

标记-清除算法，分为标记和清除两个阶段。

标记：标记需要回收的对象

清除：回收需要被回收对象所占用的空间。

缺点：产生内存碎片，后续可能发生对象不能找到连续空间的问题。



### 复制算法

将内存划分为两个相等的区域。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。

优点：可以解决内存碎片的问题。

缺点：内存使用率不高，只有原来的一半。



### 标记-整理算法

标记-整理算法，分为标记和整理两个阶段。

标记：标记需要回收的对象

整理：将存活对象移向内存的另一端，然后清除端边界外的对象。



### 分代收集

根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代。根据各个年代的特点选择合适的垃圾收集算法。比如新生代采用复制算法，老年代采用标记整理算法。



### 三色标记算法

分为三种颜色，白灰黑。

+ 白：没有检查过的
+ 灰：自身被检查了，成员没被检查完
+ 黑：自身和成员都被检查完了



开始时，所有对象都在白色集合。

- 初始标记阶段，指的是标记 GCRoots 直接引用的节点，将它们标记为灰色。需要 「Stop the World」。
- 并发标记阶段，指的是从灰色节点开始，去扫描整个引用链，然后将它们标记为黑色。不需要「Stop the World」。
- 重新标记阶段，标记第二阶段重新产生的垃圾。需要 「Stop the World」。
- 并发清除，指的是将已经确定为垃圾的对象清除掉，即白色。不需要「Stop the World」。



## 垃圾收集器

JDK 默认垃圾收集器（使用 `java -XX:+PrintCommandLineFlags -version` 命令查看）：

- JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）
- JDK 9 ~ JDK20: G1

### Serial 和Serial Old收集器

单线程的收集器，需要stop the world。

早期收集器，当时硬件环境配置不高，大多是单核CPU。

**Serial：新生代采用标记-复制算法，Serial Old：老年代采用标记-整理算法。**



### Parallel Scavenge 和 Parallel Old 收集器

多线程的收集器，需要stop the world。

吞吐量优先，效率高，尽量减少GC次数，每次GC时间长。

**Parallel Scavenge：新生代采用标记-复制算法，Parallel Old：老年代采用标记-整理算法。**



### ParNew 收集器

多线程的收集器，需要stop the world。唯一一个能与CMS配合一起使用新生代收集器

停顿时间优先，频繁GC，但每次停顿时间段，吞吐量低一些。

**ParNew ：新生代采用标记-复制算法**





### CMS收集器

分为四阶段

1. 初始标记：标记GC Roots直接引用的对象，需要stop the world，防止用户线程继续产生GC ROOT引用的对象。速度很快，只会标记GC Root的直接引用，并不会对整个GC Root的引用进行遍历。
2. 并发标记：标记好的GC Root对象进行深度的遍历，找到所有与GC Root关联的对象并进行标记，这个过程中是采用多线程的方式进行遍历标记。不需要stop the world。
3. 重新标记：标记第二阶段（并发标记）时产生的新的垃圾。需要stop the world。
4. 并发清除：不需要stop the world。与用户线程一起工作，清理垃圾。



CMS的目的是垃圾清理线程与用户线程并发，所以不能很好的清理垃圾，而且必须是标记-清除，不能是标记-整理（对象的地址不能改变），所以最后会出现内存碎片，并且有浮动垃圾无法清除

> 浮动垃圾
>
> 并发清除阶段：垃圾收集线程是和用户线程同时进行，此时用户线程产生的垃圾无法回收，需要等到下一次GC。这些在垃圾收集过程中新产生的垃圾称为浮动垃圾。

当并发清除不能清理出足够的内存空间时(可能是内存碎片太多)，也会暂停用户线程，进行标记整理。

> 这次的stop the world可能时间会很长

CMS：老年代采用标记清除法+标记整理法.

配合新生代的ParNew使用。

停顿时间优先。

**从 JDK9 开始，CMS 收集器已被弃用**



### G1收集器

G1舍弃了原有的把堆空间分为连续的三个空间的方案(新生代，老年代，元空间/永久代)。

而是把堆空间划分成一块块大小相等的region，一般2000多块。在逻辑上，eden regions构成Eden空间，survivor regions构成Survivor空间，old regions构成了old 空间。

**不要求整个Eden区、年轻代或者老年代都是连续的**,**不再坚持固定大小和固定数量**。

同时维护了一个Collect Set集合，记录了待回收的Region块信息同时也包括了每个Region块可回收的大小空间

![image-20240327092434349](D:\blog\docs\JVM\img\垃圾回收.assets\image-20240327092434349.png)



分为四阶段

1. 初始标记：标记GC Roots直接引用的对象，需要stop the world，防止用户线程继续产生GC ROOT引用的对象。速度很快，只会标记GC Root的直接引用，并不会对整个GC Root的引用进行遍历。
2. 并发标记：标记好的GC Root对象进行深度的遍历，找到所有与GC Root关联的对象并进行标记，这个过程中是采用多线程的方式进行遍历标记。不需要stop the world。
3. 最终标记：标记第二阶段（并发标记）时产生的新的垃圾。需要stop the world。
4. 筛选回收：把存活的对象复制到空闲Region区域，再根据Collect Set记录的可回收Region信息进行筛选，计算Region回收成本，根据用户设定的停顿时间值制定回收计划，根据回收计划筛选合适的Region区域进行回收。



**回收算法：**从局部来说G1是使用的标记复制法，把存活对象从一个Region复制到另外的Region，但从整个堆来说G1的逻辑又相当于是标记整理法，每次垃圾收集时会把存活的对象整理到其他对应区域的Region里，再把原来的Region标记为可回收区域记录到CSet里，所以G1的每一次回收都是一次整理过程，所以也就不会产生空间碎片问题。



G1的收集区域是整个堆空间，不需要其他收集器配合。

但因为需要维护的额外信息比较多，所以需要的内存空间也要大。



**从 JDK9 开始，G1 垃圾收集器是默认的垃圾收集器**
