

# Java内存区域





## 运行时数据区域



+ 程序计数器

+ 虚拟机栈

+ 本地方法栈

+ 堆

+ 方法区

+ 直接内存

  

**线程私有的**：

+ 程序计数器
+ 虚拟机栈
+ 本地方法栈

**线程共享的**：

+ 堆
+ 方法区
+ 直接内存



### 程序计数器

程序计数器是线程私有的。

当前线程所执行的行号指示器。由于JVM可以并发执行线程，因此会存在线程之间的切换，而这个时候就程序计数器会记录下当前程序执行到的位置，以便在其他线程执行完毕后，恢复现场继续执行。

程序计数器的生命周期与线程相同。

程序计数器不会出现`OutOfMemoryError`。

如果正在执行的是Native方法，计数器的值则为空（undefined）。

如果线程正在执行的是应该Java方法，这个计数器记录的是正在执行虚拟机字节码指令的地址。



### 虚拟机栈

虚拟机栈是线程私有的。

虚拟机栈的生命周期与线程相同。

在虚拟机栈内存不够的时候会`OutOfMemoryError`，在线程运行中需要更大的虚拟机栈时会出现StackOverFlowError(如果出现死循环，无限调用方法，栈帧被无限压入，就会出现)。

方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。

#### 栈帧

1. 局部变量表
2. 操作数栈
3. 动态链接
4. 方法返回地址

##### 局部变量表

局部变量表是存放**方法参数**和**局部变量**（boolean、byte、char、short、int、float、long、double）的区域。

##### 操作数栈

主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。

##### 动态链接

主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 **动态连接** 。

方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪一个方法)，这也是Java强大的扩展能力，在运行期间才能确定目标方法的**直接引用**。

所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用。

##### 方法返回地址

返回分为 正常返回 和 异常退出。

无论何种退出情况，都会弹出栈帧，返回至方法当前被调用的位置，这也程序才能继续执行。

方法退出的过程相当于弹出当前栈帧。



### 本地方法栈

本地方法栈是线程私有的。

Java虚拟机栈是调用Java方法；本地方法栈是调用本地`native`方法，可以认为是通过 `JNI` (Java Native Interface) 直接调用本地 C/C++ 库，不受JVM控制。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误。



### 堆

堆是线程共享的。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永久代(Permanent Generation)

**JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。** 

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 元空间(Metaspace)



新生代又被分为Eden区和两个Survivor区(s0、s1)。

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

堆这里最容易出现的就是 `OutOfMemoryError` 错误，并且出现这种错误之后的表现形式还会有几种，比如：

1. **`java.lang.OutOfMemoryError: GC Overhead Limit Exceeded`**：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
2. **`java.lang.OutOfMemoryError: Java heap space`** :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过`-Xmx`参数配置，若没有特别配置，将会使用默认值，详见：[Default Java 8 max heap sizeopen in new window](https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size))

#### 字符串常量池

JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 **字符串常量池**和**静态变量**从永久代移动了 Java 堆中。

**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

**JDK 1.7 为什么要将字符串常量池移动到堆中？**

主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。



### 方法区

方法区是线程共享的。

虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。

方法区会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。



**为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?**

1、整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。

> 当元空间溢出时会得到如下错误：`java.lang.OutOfMemoryError: MetaSpace`

你可以使用 `-XX：MaxMetaspaceSize` 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。`-XX：MetaspaceSize` 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。

2、元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。

#### 运行时常量池

常量池表会在类加载后存放到方法区的运行时常量池中。.

Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 **常量池表(Constant Pool Table)** 。

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 `OutOfMemoryError` 错误。



### 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 `OutOfMemoryError` 错误出现。

通常，访问直接内存的速度会优于Java堆。即读写性能高。因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存

直接内存也可能导致`OutOfMemoryError`异常

由于直接内存在Java堆外，因此它的大小不会直接受限于`-Xmx`指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存

缺点

- 分配回收成本较高
- 不受JVM内存回收管理

直接内存大小可以通过`MaxDirectMemorySize`设置；如果不指定，默认与堆的最大值`-Xmx`参数值一致

**简单理解：java process memory = java heap + native memory**

JDK1.4 中新加入的 **NIO（Non-Blocking I/O，也被称为 New I/O）**，引入了一种基于**通道（Channel）**与**缓存区（Buffer）**的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。

读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要内存如下图的操作。使用IO，这里需要两份内存存储重复数据，效率低 ![image.png](../img/JVM内存区域.assets\ad9465e147144ec0957db3d10a6e01b0tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp)

使用NIO时，如图所示，操作系统划出的直接缓存区可以被java代码直接访问，只有一份。NIO适合对大文件的读写操作 ![image.png](../img/JVM内存区域.assets\787a58bb65d14cefa3420e7f387d0fd4tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp)

