

# 事务隔离级别



根据在事务并发执行中遇到问题的不同，可以把事务分为不同的隔离级别。



## 事务并发执行遇到的问题

### 脏写

一个事务修改了另一个未提交事务修改过的数据，那就意味着发生了脏写

### 脏读

一个事务读到了另一个未提交事务修改过的数据，那就意味着发生了脏读



### 不可重复读

一个事务读取到另一个已经提交的事务修改过的数据。

### 幻读

事务A 按照一定条件进行数据读取， 期间事务B插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B 新插入的数据，称为幻读



## 隔离级别

根据解决不同的并发问题划分了不同的隔离级别

### `READ UNCOMMITTED`：读未提交

可能发生脏读、不可重复读和幻读问题。

### `READ COMMITTED`：读已提交

通过MVCC实现，可能发生不可重复读和幻读问题

### `REPEATABLE READ`：可重复读

通过MVCC实现，可能发生幻读问题

### `SERIALIZABLE`：串行化

通过加锁实现，没有并发问题

串行化下，任何sql都是串行的。

> 任何隔离级别都会发生脏写





## 脏读演示

现有用户1有10块钱。

![image-20240327220230235](D:\blog\docs\mysql\img\事务隔离级别.assets\image-20240327220230235.png)

设置隔离级别为读未提交

```sql
set tx_isolation='read-uncommitted';
```

事务A开始事务，查询用户1的余额

```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

BEGIN;

select * from user where id = 1;
```

![image-20240327215904959](D:\blog\docs\mysql\img\事务隔离级别.assets\image-20240327215904959.png)



事务B开启事务，修改用户1的余额为20

```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

BEGIN;

update user set amount = amount + 10 where id = 1;
```

再去事务A执行查询操作，发现用户1的余额为20。此时事务B并发提交事务。

![image-20240327215952505](D:\blog\docs\mysql\img\事务隔离级别.assets\image-20240327215952505.png)



可以看到读未提交会产生脏读。

如果一个事务读到了另一个未提交事务修改过的数据，那就意味着发生了脏读

## 不可重复读演示

现有用户1有10块钱。

![image-20240327220230235](D:\blog\docs\mysql\img\事务隔离级别.assets\image-20240327220230235.png)

设置隔离级别为读已提交

事务A开始事务，查询用户1的余额

```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

BEGIN;

select * from user where id = 1;
```

![image-20240327215904959](D:\blog\docs\mysql\img\事务隔离级别.assets\image-20240327215904959.png)

事务B开启事务，修改用户1的余额为20

```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

BEGIN;

update user set amount = amount + 10 where id = 1;
```

再去事务A执行查询操作，发现用户1的余额还是10，说明读已提交没有脏读问题。

![image-20240327215904959](D:\blog\docs\mysql\img\事务隔离级别.assets\image-20240327215904959.png)

提交事务B，再去查询事务A中用户1的余额

![image-20240327220551320](D:\blog\docs\mysql\img\事务隔离级别.assets\image-20240327220551320.png)

发现变成了20。

一个事务读取到另一个已经提交的事务修改过的数据，那就意味着发生了不可重复读。

## 幻读演示

现有两个用户1和2

![image-20240327220230235](D:\blog\docs\mysql\img\事务隔离级别.assets\image-20240327220824772.png)

设置隔离级别为读已提交(mysql的默认隔离级别)

事务A开始事务，查询用户1的余额

```sql
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ ;

BEGIN;

select * from user where id = 1;
```



![image-20240327221354025](D:\blog\docs\mysql\img\事务隔离级别.assets\image-20240327221354025.png)

事务B开启事务，修改用户1的余额为20，并提交事务。

再去事务A查询用户1的余额，发现还是10

![image-20240327221354025](D:\blog\docs\mysql\img\事务隔离级别.assets\image-20240327221354025.png)

说明可重复读没有不可重复读的问题。



事务A中查询id小于10的数据

![image-20240327221246968](D:\blog\docs\mysql\img\事务隔离级别.assets\image-20240327221246968.png)

事务B中新增一条id为3的数据，并提交。

再次在事务A中查询id小于10的数据

![image-20240327221237928](D:\blog\docs\mysql\img\事务隔离级别.assets\image-20240327221237928.png)

发现出现了三条。说明出现了幻读。



